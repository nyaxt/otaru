// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.2
// source: otaru.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// FileSystemServiceClient is the client API for FileSystemService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FileSystemServiceClient interface {
	ListDir(ctx context.Context, in *ListDirRequest, opts ...grpc.CallOption) (*ListDirResponse, error)
	FindNodeFullPath(ctx context.Context, in *FindNodeFullPathRequest, opts ...grpc.CallOption) (*FindNodeFullPathResponse, error)
	Attr(ctx context.Context, in *AttrRequest, opts ...grpc.CallOption) (*AttrResponse, error)
	Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error)
	Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error)
	ReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (*ReadFileResponse, error)
	WriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpc.CallOption) (*WriteFileResponse, error)
	Rename(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*RenameResponse, error)
}

type fileSystemServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFileSystemServiceClient(cc grpc.ClientConnInterface) FileSystemServiceClient {
	return &fileSystemServiceClient{cc}
}

func (c *fileSystemServiceClient) ListDir(ctx context.Context, in *ListDirRequest, opts ...grpc.CallOption) (*ListDirResponse, error) {
	out := new(ListDirResponse)
	err := c.cc.Invoke(ctx, "/pb.FileSystemService/ListDir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemServiceClient) FindNodeFullPath(ctx context.Context, in *FindNodeFullPathRequest, opts ...grpc.CallOption) (*FindNodeFullPathResponse, error) {
	out := new(FindNodeFullPathResponse)
	err := c.cc.Invoke(ctx, "/pb.FileSystemService/FindNodeFullPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemServiceClient) Attr(ctx context.Context, in *AttrRequest, opts ...grpc.CallOption) (*AttrResponse, error) {
	out := new(AttrResponse)
	err := c.cc.Invoke(ctx, "/pb.FileSystemService/Attr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemServiceClient) Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) {
	out := new(CreateResponse)
	err := c.cc.Invoke(ctx, "/pb.FileSystemService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemServiceClient) Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error) {
	out := new(RemoveResponse)
	err := c.cc.Invoke(ctx, "/pb.FileSystemService/Remove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemServiceClient) ReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (*ReadFileResponse, error) {
	out := new(ReadFileResponse)
	err := c.cc.Invoke(ctx, "/pb.FileSystemService/ReadFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemServiceClient) WriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpc.CallOption) (*WriteFileResponse, error) {
	out := new(WriteFileResponse)
	err := c.cc.Invoke(ctx, "/pb.FileSystemService/WriteFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemServiceClient) Rename(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*RenameResponse, error) {
	out := new(RenameResponse)
	err := c.cc.Invoke(ctx, "/pb.FileSystemService/Rename", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileSystemServiceServer is the server API for FileSystemService service.
// All implementations must embed UnimplementedFileSystemServiceServer
// for forward compatibility
type FileSystemServiceServer interface {
	ListDir(context.Context, *ListDirRequest) (*ListDirResponse, error)
	FindNodeFullPath(context.Context, *FindNodeFullPathRequest) (*FindNodeFullPathResponse, error)
	Attr(context.Context, *AttrRequest) (*AttrResponse, error)
	Create(context.Context, *CreateRequest) (*CreateResponse, error)
	Remove(context.Context, *RemoveRequest) (*RemoveResponse, error)
	ReadFile(context.Context, *ReadFileRequest) (*ReadFileResponse, error)
	WriteFile(context.Context, *WriteFileRequest) (*WriteFileResponse, error)
	Rename(context.Context, *RenameRequest) (*RenameResponse, error)
	mustEmbedUnimplementedFileSystemServiceServer()
}

// UnimplementedFileSystemServiceServer must be embedded to have forward compatible implementations.
type UnimplementedFileSystemServiceServer struct {
}

func (UnimplementedFileSystemServiceServer) ListDir(context.Context, *ListDirRequest) (*ListDirResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDir not implemented")
}
func (UnimplementedFileSystemServiceServer) FindNodeFullPath(context.Context, *FindNodeFullPathRequest) (*FindNodeFullPathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindNodeFullPath not implemented")
}
func (UnimplementedFileSystemServiceServer) Attr(context.Context, *AttrRequest) (*AttrResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attr not implemented")
}
func (UnimplementedFileSystemServiceServer) Create(context.Context, *CreateRequest) (*CreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedFileSystemServiceServer) Remove(context.Context, *RemoveRequest) (*RemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Remove not implemented")
}
func (UnimplementedFileSystemServiceServer) ReadFile(context.Context, *ReadFileRequest) (*ReadFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadFile not implemented")
}
func (UnimplementedFileSystemServiceServer) WriteFile(context.Context, *WriteFileRequest) (*WriteFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteFile not implemented")
}
func (UnimplementedFileSystemServiceServer) Rename(context.Context, *RenameRequest) (*RenameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rename not implemented")
}
func (UnimplementedFileSystemServiceServer) mustEmbedUnimplementedFileSystemServiceServer() {}

// UnsafeFileSystemServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FileSystemServiceServer will
// result in compilation errors.
type UnsafeFileSystemServiceServer interface {
	mustEmbedUnimplementedFileSystemServiceServer()
}

func RegisterFileSystemServiceServer(s grpc.ServiceRegistrar, srv FileSystemServiceServer) {
	s.RegisterService(&FileSystemService_ServiceDesc, srv)
}

func _FileSystemService_ListDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDirRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServiceServer).ListDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FileSystemService/ListDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServiceServer).ListDir(ctx, req.(*ListDirRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystemService_FindNodeFullPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindNodeFullPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServiceServer).FindNodeFullPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FileSystemService/FindNodeFullPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServiceServer).FindNodeFullPath(ctx, req.(*FindNodeFullPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystemService_Attr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServiceServer).Attr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FileSystemService/Attr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServiceServer).Attr(ctx, req.(*AttrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystemService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FileSystemService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServiceServer).Create(ctx, req.(*CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystemService_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServiceServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FileSystemService/Remove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServiceServer).Remove(ctx, req.(*RemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystemService_ReadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServiceServer).ReadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FileSystemService/ReadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServiceServer).ReadFile(ctx, req.(*ReadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystemService_WriteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServiceServer).WriteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FileSystemService/WriteFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServiceServer).WriteFile(ctx, req.(*WriteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystemService_Rename_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServiceServer).Rename(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FileSystemService/Rename",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServiceServer).Rename(ctx, req.(*RenameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FileSystemService_ServiceDesc is the grpc.ServiceDesc for FileSystemService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FileSystemService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.FileSystemService",
	HandlerType: (*FileSystemServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListDir",
			Handler:    _FileSystemService_ListDir_Handler,
		},
		{
			MethodName: "FindNodeFullPath",
			Handler:    _FileSystemService_FindNodeFullPath_Handler,
		},
		{
			MethodName: "Attr",
			Handler:    _FileSystemService_Attr_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _FileSystemService_Create_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _FileSystemService_Remove_Handler,
		},
		{
			MethodName: "ReadFile",
			Handler:    _FileSystemService_ReadFile_Handler,
		},
		{
			MethodName: "WriteFile",
			Handler:    _FileSystemService_WriteFile_Handler,
		},
		{
			MethodName: "Rename",
			Handler:    _FileSystemService_Rename_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "otaru.proto",
}

// BlobstoreServiceClient is the client API for BlobstoreService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlobstoreServiceClient interface {
	GetConfig(ctx context.Context, in *GetBlobstoreConfigRequest, opts ...grpc.CallOption) (*GetBlobstoreConfigResponse, error)
	GetEntries(ctx context.Context, in *GetEntriesRequest, opts ...grpc.CallOption) (*GetEntriesResponse, error)
	ReduceCache(ctx context.Context, in *ReduceCacheRequest, opts ...grpc.CallOption) (*ReduceCacheResponse, error)
}

type blobstoreServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBlobstoreServiceClient(cc grpc.ClientConnInterface) BlobstoreServiceClient {
	return &blobstoreServiceClient{cc}
}

func (c *blobstoreServiceClient) GetConfig(ctx context.Context, in *GetBlobstoreConfigRequest, opts ...grpc.CallOption) (*GetBlobstoreConfigResponse, error) {
	out := new(GetBlobstoreConfigResponse)
	err := c.cc.Invoke(ctx, "/pb.BlobstoreService/GetConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobstoreServiceClient) GetEntries(ctx context.Context, in *GetEntriesRequest, opts ...grpc.CallOption) (*GetEntriesResponse, error) {
	out := new(GetEntriesResponse)
	err := c.cc.Invoke(ctx, "/pb.BlobstoreService/GetEntries", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blobstoreServiceClient) ReduceCache(ctx context.Context, in *ReduceCacheRequest, opts ...grpc.CallOption) (*ReduceCacheResponse, error) {
	out := new(ReduceCacheResponse)
	err := c.cc.Invoke(ctx, "/pb.BlobstoreService/ReduceCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BlobstoreServiceServer is the server API for BlobstoreService service.
// All implementations must embed UnimplementedBlobstoreServiceServer
// for forward compatibility
type BlobstoreServiceServer interface {
	GetConfig(context.Context, *GetBlobstoreConfigRequest) (*GetBlobstoreConfigResponse, error)
	GetEntries(context.Context, *GetEntriesRequest) (*GetEntriesResponse, error)
	ReduceCache(context.Context, *ReduceCacheRequest) (*ReduceCacheResponse, error)
	mustEmbedUnimplementedBlobstoreServiceServer()
}

// UnimplementedBlobstoreServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBlobstoreServiceServer struct {
}

func (UnimplementedBlobstoreServiceServer) GetConfig(context.Context, *GetBlobstoreConfigRequest) (*GetBlobstoreConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfig not implemented")
}
func (UnimplementedBlobstoreServiceServer) GetEntries(context.Context, *GetEntriesRequest) (*GetEntriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEntries not implemented")
}
func (UnimplementedBlobstoreServiceServer) ReduceCache(context.Context, *ReduceCacheRequest) (*ReduceCacheResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReduceCache not implemented")
}
func (UnimplementedBlobstoreServiceServer) mustEmbedUnimplementedBlobstoreServiceServer() {}

// UnsafeBlobstoreServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlobstoreServiceServer will
// result in compilation errors.
type UnsafeBlobstoreServiceServer interface {
	mustEmbedUnimplementedBlobstoreServiceServer()
}

func RegisterBlobstoreServiceServer(s grpc.ServiceRegistrar, srv BlobstoreServiceServer) {
	s.RegisterService(&BlobstoreService_ServiceDesc, srv)
}

func _BlobstoreService_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlobstoreConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobstoreServiceServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlobstoreService/GetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobstoreServiceServer).GetConfig(ctx, req.(*GetBlobstoreConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlobstoreService_GetEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobstoreServiceServer).GetEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlobstoreService/GetEntries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobstoreServiceServer).GetEntries(ctx, req.(*GetEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlobstoreService_ReduceCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReduceCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlobstoreServiceServer).ReduceCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlobstoreService/ReduceCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlobstoreServiceServer).ReduceCache(ctx, req.(*ReduceCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BlobstoreService_ServiceDesc is the grpc.ServiceDesc for BlobstoreService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BlobstoreService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.BlobstoreService",
	HandlerType: (*BlobstoreServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConfig",
			Handler:    _BlobstoreService_GetConfig_Handler,
		},
		{
			MethodName: "GetEntries",
			Handler:    _BlobstoreService_GetEntries_Handler,
		},
		{
			MethodName: "ReduceCache",
			Handler:    _BlobstoreService_ReduceCache_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "otaru.proto",
}

// INodeDBServiceClient is the client API for INodeDBService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type INodeDBServiceClient interface {
	GetINodeDBStats(ctx context.Context, in *GetINodeDBStatsRequest, opts ...grpc.CallOption) (*GetINodeDBStatsResponse, error)
}

type iNodeDBServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewINodeDBServiceClient(cc grpc.ClientConnInterface) INodeDBServiceClient {
	return &iNodeDBServiceClient{cc}
}

func (c *iNodeDBServiceClient) GetINodeDBStats(ctx context.Context, in *GetINodeDBStatsRequest, opts ...grpc.CallOption) (*GetINodeDBStatsResponse, error) {
	out := new(GetINodeDBStatsResponse)
	err := c.cc.Invoke(ctx, "/pb.INodeDBService/GetINodeDBStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// INodeDBServiceServer is the server API for INodeDBService service.
// All implementations must embed UnimplementedINodeDBServiceServer
// for forward compatibility
type INodeDBServiceServer interface {
	GetINodeDBStats(context.Context, *GetINodeDBStatsRequest) (*GetINodeDBStatsResponse, error)
	mustEmbedUnimplementedINodeDBServiceServer()
}

// UnimplementedINodeDBServiceServer must be embedded to have forward compatible implementations.
type UnimplementedINodeDBServiceServer struct {
}

func (UnimplementedINodeDBServiceServer) GetINodeDBStats(context.Context, *GetINodeDBStatsRequest) (*GetINodeDBStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetINodeDBStats not implemented")
}
func (UnimplementedINodeDBServiceServer) mustEmbedUnimplementedINodeDBServiceServer() {}

// UnsafeINodeDBServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to INodeDBServiceServer will
// result in compilation errors.
type UnsafeINodeDBServiceServer interface {
	mustEmbedUnimplementedINodeDBServiceServer()
}

func RegisterINodeDBServiceServer(s grpc.ServiceRegistrar, srv INodeDBServiceServer) {
	s.RegisterService(&INodeDBService_ServiceDesc, srv)
}

func _INodeDBService_GetINodeDBStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetINodeDBStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(INodeDBServiceServer).GetINodeDBStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.INodeDBService/GetINodeDBStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(INodeDBServiceServer).GetINodeDBStats(ctx, req.(*GetINodeDBStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// INodeDBService_ServiceDesc is the grpc.ServiceDesc for INodeDBService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var INodeDBService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.INodeDBService",
	HandlerType: (*INodeDBServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetINodeDBStats",
			Handler:    _INodeDBService_GetINodeDBStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "otaru.proto",
}

// LoggerServiceClient is the client API for LoggerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoggerServiceClient interface {
	GetCategories(ctx context.Context, in *GetCategoriesRequest, opts ...grpc.CallOption) (*GetCategoriesResponse, error)
	SetCategory(ctx context.Context, in *SetCategoryRequest, opts ...grpc.CallOption) (*SetCategoryResponse, error)
	QueryLogs(ctx context.Context, in *QueryLogsRequest, opts ...grpc.CallOption) (*QueryLogsResponse, error)
	GetLatestLogEntryId(ctx context.Context, in *GetLatestLogEntryIdRequest, opts ...grpc.CallOption) (*GetLatestLogEntryIdResponse, error)
}

type loggerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLoggerServiceClient(cc grpc.ClientConnInterface) LoggerServiceClient {
	return &loggerServiceClient{cc}
}

func (c *loggerServiceClient) GetCategories(ctx context.Context, in *GetCategoriesRequest, opts ...grpc.CallOption) (*GetCategoriesResponse, error) {
	out := new(GetCategoriesResponse)
	err := c.cc.Invoke(ctx, "/pb.LoggerService/GetCategories", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerServiceClient) SetCategory(ctx context.Context, in *SetCategoryRequest, opts ...grpc.CallOption) (*SetCategoryResponse, error) {
	out := new(SetCategoryResponse)
	err := c.cc.Invoke(ctx, "/pb.LoggerService/SetCategory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerServiceClient) QueryLogs(ctx context.Context, in *QueryLogsRequest, opts ...grpc.CallOption) (*QueryLogsResponse, error) {
	out := new(QueryLogsResponse)
	err := c.cc.Invoke(ctx, "/pb.LoggerService/QueryLogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loggerServiceClient) GetLatestLogEntryId(ctx context.Context, in *GetLatestLogEntryIdRequest, opts ...grpc.CallOption) (*GetLatestLogEntryIdResponse, error) {
	out := new(GetLatestLogEntryIdResponse)
	err := c.cc.Invoke(ctx, "/pb.LoggerService/GetLatestLogEntryId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoggerServiceServer is the server API for LoggerService service.
// All implementations must embed UnimplementedLoggerServiceServer
// for forward compatibility
type LoggerServiceServer interface {
	GetCategories(context.Context, *GetCategoriesRequest) (*GetCategoriesResponse, error)
	SetCategory(context.Context, *SetCategoryRequest) (*SetCategoryResponse, error)
	QueryLogs(context.Context, *QueryLogsRequest) (*QueryLogsResponse, error)
	GetLatestLogEntryId(context.Context, *GetLatestLogEntryIdRequest) (*GetLatestLogEntryIdResponse, error)
	mustEmbedUnimplementedLoggerServiceServer()
}

// UnimplementedLoggerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLoggerServiceServer struct {
}

func (UnimplementedLoggerServiceServer) GetCategories(context.Context, *GetCategoriesRequest) (*GetCategoriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategories not implemented")
}
func (UnimplementedLoggerServiceServer) SetCategory(context.Context, *SetCategoryRequest) (*SetCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCategory not implemented")
}
func (UnimplementedLoggerServiceServer) QueryLogs(context.Context, *QueryLogsRequest) (*QueryLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryLogs not implemented")
}
func (UnimplementedLoggerServiceServer) GetLatestLogEntryId(context.Context, *GetLatestLogEntryIdRequest) (*GetLatestLogEntryIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLatestLogEntryId not implemented")
}
func (UnimplementedLoggerServiceServer) mustEmbedUnimplementedLoggerServiceServer() {}

// UnsafeLoggerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoggerServiceServer will
// result in compilation errors.
type UnsafeLoggerServiceServer interface {
	mustEmbedUnimplementedLoggerServiceServer()
}

func RegisterLoggerServiceServer(s grpc.ServiceRegistrar, srv LoggerServiceServer) {
	s.RegisterService(&LoggerService_ServiceDesc, srv)
}

func _LoggerService_GetCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCategoriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServiceServer).GetCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.LoggerService/GetCategories",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServiceServer).GetCategories(ctx, req.(*GetCategoriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoggerService_SetCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServiceServer).SetCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.LoggerService/SetCategory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServiceServer).SetCategory(ctx, req.(*SetCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoggerService_QueryLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServiceServer).QueryLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.LoggerService/QueryLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServiceServer).QueryLogs(ctx, req.(*QueryLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoggerService_GetLatestLogEntryId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestLogEntryIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoggerServiceServer).GetLatestLogEntryId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.LoggerService/GetLatestLogEntryId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoggerServiceServer).GetLatestLogEntryId(ctx, req.(*GetLatestLogEntryIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LoggerService_ServiceDesc is the grpc.ServiceDesc for LoggerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoggerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.LoggerService",
	HandlerType: (*LoggerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCategories",
			Handler:    _LoggerService_GetCategories_Handler,
		},
		{
			MethodName: "SetCategory",
			Handler:    _LoggerService_SetCategory_Handler,
		},
		{
			MethodName: "QueryLogs",
			Handler:    _LoggerService_QueryLogs_Handler,
		},
		{
			MethodName: "GetLatestLogEntryId",
			Handler:    _LoggerService_GetLatestLogEntryId_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "otaru.proto",
}

// SystemInfoServiceClient is the client API for SystemInfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SystemInfoServiceClient interface {
	GetSystemInfo(ctx context.Context, in *GetSystemInfoRequest, opts ...grpc.CallOption) (*SystemInfoResponse, error)
	GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*VersionResponse, error)
	Whoami(ctx context.Context, in *WhoamiRequest, opts ...grpc.CallOption) (*WhoamiResponse, error)
	AuthTestAnonymous(ctx context.Context, in *AuthTestRequest, opts ...grpc.CallOption) (*AuthTestResponse, error)
	AuthTestReadOnly(ctx context.Context, in *AuthTestRequest, opts ...grpc.CallOption) (*AuthTestResponse, error)
	AuthTestAdmin(ctx context.Context, in *AuthTestRequest, opts ...grpc.CallOption) (*AuthTestResponse, error)
}

type systemInfoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSystemInfoServiceClient(cc grpc.ClientConnInterface) SystemInfoServiceClient {
	return &systemInfoServiceClient{cc}
}

func (c *systemInfoServiceClient) GetSystemInfo(ctx context.Context, in *GetSystemInfoRequest, opts ...grpc.CallOption) (*SystemInfoResponse, error) {
	out := new(SystemInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.SystemInfoService/GetSystemInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemInfoServiceClient) GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/pb.SystemInfoService/GetVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemInfoServiceClient) Whoami(ctx context.Context, in *WhoamiRequest, opts ...grpc.CallOption) (*WhoamiResponse, error) {
	out := new(WhoamiResponse)
	err := c.cc.Invoke(ctx, "/pb.SystemInfoService/Whoami", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemInfoServiceClient) AuthTestAnonymous(ctx context.Context, in *AuthTestRequest, opts ...grpc.CallOption) (*AuthTestResponse, error) {
	out := new(AuthTestResponse)
	err := c.cc.Invoke(ctx, "/pb.SystemInfoService/AuthTestAnonymous", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemInfoServiceClient) AuthTestReadOnly(ctx context.Context, in *AuthTestRequest, opts ...grpc.CallOption) (*AuthTestResponse, error) {
	out := new(AuthTestResponse)
	err := c.cc.Invoke(ctx, "/pb.SystemInfoService/AuthTestReadOnly", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemInfoServiceClient) AuthTestAdmin(ctx context.Context, in *AuthTestRequest, opts ...grpc.CallOption) (*AuthTestResponse, error) {
	out := new(AuthTestResponse)
	err := c.cc.Invoke(ctx, "/pb.SystemInfoService/AuthTestAdmin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SystemInfoServiceServer is the server API for SystemInfoService service.
// All implementations must embed UnimplementedSystemInfoServiceServer
// for forward compatibility
type SystemInfoServiceServer interface {
	GetSystemInfo(context.Context, *GetSystemInfoRequest) (*SystemInfoResponse, error)
	GetVersion(context.Context, *GetVersionRequest) (*VersionResponse, error)
	Whoami(context.Context, *WhoamiRequest) (*WhoamiResponse, error)
	AuthTestAnonymous(context.Context, *AuthTestRequest) (*AuthTestResponse, error)
	AuthTestReadOnly(context.Context, *AuthTestRequest) (*AuthTestResponse, error)
	AuthTestAdmin(context.Context, *AuthTestRequest) (*AuthTestResponse, error)
	mustEmbedUnimplementedSystemInfoServiceServer()
}

// UnimplementedSystemInfoServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSystemInfoServiceServer struct {
}

func (UnimplementedSystemInfoServiceServer) GetSystemInfo(context.Context, *GetSystemInfoRequest) (*SystemInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemInfo not implemented")
}
func (UnimplementedSystemInfoServiceServer) GetVersion(context.Context, *GetVersionRequest) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedSystemInfoServiceServer) Whoami(context.Context, *WhoamiRequest) (*WhoamiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Whoami not implemented")
}
func (UnimplementedSystemInfoServiceServer) AuthTestAnonymous(context.Context, *AuthTestRequest) (*AuthTestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthTestAnonymous not implemented")
}
func (UnimplementedSystemInfoServiceServer) AuthTestReadOnly(context.Context, *AuthTestRequest) (*AuthTestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthTestReadOnly not implemented")
}
func (UnimplementedSystemInfoServiceServer) AuthTestAdmin(context.Context, *AuthTestRequest) (*AuthTestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthTestAdmin not implemented")
}
func (UnimplementedSystemInfoServiceServer) mustEmbedUnimplementedSystemInfoServiceServer() {}

// UnsafeSystemInfoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SystemInfoServiceServer will
// result in compilation errors.
type UnsafeSystemInfoServiceServer interface {
	mustEmbedUnimplementedSystemInfoServiceServer()
}

func RegisterSystemInfoServiceServer(s grpc.ServiceRegistrar, srv SystemInfoServiceServer) {
	s.RegisterService(&SystemInfoService_ServiceDesc, srv)
}

func _SystemInfoService_GetSystemInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSystemInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemInfoServiceServer).GetSystemInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemInfoService/GetSystemInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemInfoServiceServer).GetSystemInfo(ctx, req.(*GetSystemInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemInfoService_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemInfoServiceServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemInfoService/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemInfoServiceServer).GetVersion(ctx, req.(*GetVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemInfoService_Whoami_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WhoamiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemInfoServiceServer).Whoami(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemInfoService/Whoami",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemInfoServiceServer).Whoami(ctx, req.(*WhoamiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemInfoService_AuthTestAnonymous_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthTestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemInfoServiceServer).AuthTestAnonymous(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemInfoService/AuthTestAnonymous",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemInfoServiceServer).AuthTestAnonymous(ctx, req.(*AuthTestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemInfoService_AuthTestReadOnly_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthTestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemInfoServiceServer).AuthTestReadOnly(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemInfoService/AuthTestReadOnly",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemInfoServiceServer).AuthTestReadOnly(ctx, req.(*AuthTestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemInfoService_AuthTestAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthTestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemInfoServiceServer).AuthTestAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SystemInfoService/AuthTestAdmin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemInfoServiceServer).AuthTestAdmin(ctx, req.(*AuthTestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SystemInfoService_ServiceDesc is the grpc.ServiceDesc for SystemInfoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SystemInfoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.SystemInfoService",
	HandlerType: (*SystemInfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSystemInfo",
			Handler:    _SystemInfoService_GetSystemInfo_Handler,
		},
		{
			MethodName: "GetVersion",
			Handler:    _SystemInfoService_GetVersion_Handler,
		},
		{
			MethodName: "Whoami",
			Handler:    _SystemInfoService_Whoami_Handler,
		},
		{
			MethodName: "AuthTestAnonymous",
			Handler:    _SystemInfoService_AuthTestAnonymous_Handler,
		},
		{
			MethodName: "AuthTestReadOnly",
			Handler:    _SystemInfoService_AuthTestReadOnly_Handler,
		},
		{
			MethodName: "AuthTestAdmin",
			Handler:    _SystemInfoService_AuthTestAdmin_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "otaru.proto",
}

// FeServiceClient is the client API for FeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FeServiceClient interface {
	ListHosts(ctx context.Context, in *ListHostsRequest, opts ...grpc.CallOption) (*ListHostsResponse, error)
	ListLocalDir(ctx context.Context, in *ListLocalDirRequest, opts ...grpc.CallOption) (*ListLocalDirResponse, error)
	MkdirLocal(ctx context.Context, in *MkdirLocalRequest, opts ...grpc.CallOption) (*MkdirLocalResponse, error)
	CopyLocal(ctx context.Context, in *CopyLocalRequest, opts ...grpc.CallOption) (*CopyLocalResponse, error)
	MoveLocal(ctx context.Context, in *MoveLocalRequest, opts ...grpc.CallOption) (*MoveLocalResponse, error)
	Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (*DownloadResponse, error)
	Upload(ctx context.Context, in *UploadRequest, opts ...grpc.CallOption) (*UploadResponse, error)
	RemoteMove(ctx context.Context, in *RemoteMoveRequest, opts ...grpc.CallOption) (*RemoteMoveResponse, error)
	RemoveLocal(ctx context.Context, in *RemoveLocalRequest, opts ...grpc.CallOption) (*RemoveLocalResponse, error)
}

type feServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFeServiceClient(cc grpc.ClientConnInterface) FeServiceClient {
	return &feServiceClient{cc}
}

func (c *feServiceClient) ListHosts(ctx context.Context, in *ListHostsRequest, opts ...grpc.CallOption) (*ListHostsResponse, error) {
	out := new(ListHostsResponse)
	err := c.cc.Invoke(ctx, "/pb.FeService/ListHosts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feServiceClient) ListLocalDir(ctx context.Context, in *ListLocalDirRequest, opts ...grpc.CallOption) (*ListLocalDirResponse, error) {
	out := new(ListLocalDirResponse)
	err := c.cc.Invoke(ctx, "/pb.FeService/ListLocalDir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feServiceClient) MkdirLocal(ctx context.Context, in *MkdirLocalRequest, opts ...grpc.CallOption) (*MkdirLocalResponse, error) {
	out := new(MkdirLocalResponse)
	err := c.cc.Invoke(ctx, "/pb.FeService/MkdirLocal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feServiceClient) CopyLocal(ctx context.Context, in *CopyLocalRequest, opts ...grpc.CallOption) (*CopyLocalResponse, error) {
	out := new(CopyLocalResponse)
	err := c.cc.Invoke(ctx, "/pb.FeService/CopyLocal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feServiceClient) MoveLocal(ctx context.Context, in *MoveLocalRequest, opts ...grpc.CallOption) (*MoveLocalResponse, error) {
	out := new(MoveLocalResponse)
	err := c.cc.Invoke(ctx, "/pb.FeService/MoveLocal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feServiceClient) Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (*DownloadResponse, error) {
	out := new(DownloadResponse)
	err := c.cc.Invoke(ctx, "/pb.FeService/Download", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feServiceClient) Upload(ctx context.Context, in *UploadRequest, opts ...grpc.CallOption) (*UploadResponse, error) {
	out := new(UploadResponse)
	err := c.cc.Invoke(ctx, "/pb.FeService/Upload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feServiceClient) RemoteMove(ctx context.Context, in *RemoteMoveRequest, opts ...grpc.CallOption) (*RemoteMoveResponse, error) {
	out := new(RemoteMoveResponse)
	err := c.cc.Invoke(ctx, "/pb.FeService/RemoteMove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feServiceClient) RemoveLocal(ctx context.Context, in *RemoveLocalRequest, opts ...grpc.CallOption) (*RemoveLocalResponse, error) {
	out := new(RemoveLocalResponse)
	err := c.cc.Invoke(ctx, "/pb.FeService/RemoveLocal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FeServiceServer is the server API for FeService service.
// All implementations must embed UnimplementedFeServiceServer
// for forward compatibility
type FeServiceServer interface {
	ListHosts(context.Context, *ListHostsRequest) (*ListHostsResponse, error)
	ListLocalDir(context.Context, *ListLocalDirRequest) (*ListLocalDirResponse, error)
	MkdirLocal(context.Context, *MkdirLocalRequest) (*MkdirLocalResponse, error)
	CopyLocal(context.Context, *CopyLocalRequest) (*CopyLocalResponse, error)
	MoveLocal(context.Context, *MoveLocalRequest) (*MoveLocalResponse, error)
	Download(context.Context, *DownloadRequest) (*DownloadResponse, error)
	Upload(context.Context, *UploadRequest) (*UploadResponse, error)
	RemoteMove(context.Context, *RemoteMoveRequest) (*RemoteMoveResponse, error)
	RemoveLocal(context.Context, *RemoveLocalRequest) (*RemoveLocalResponse, error)
	mustEmbedUnimplementedFeServiceServer()
}

// UnimplementedFeServiceServer must be embedded to have forward compatible implementations.
type UnimplementedFeServiceServer struct {
}

func (UnimplementedFeServiceServer) ListHosts(context.Context, *ListHostsRequest) (*ListHostsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListHosts not implemented")
}
func (UnimplementedFeServiceServer) ListLocalDir(context.Context, *ListLocalDirRequest) (*ListLocalDirResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLocalDir not implemented")
}
func (UnimplementedFeServiceServer) MkdirLocal(context.Context, *MkdirLocalRequest) (*MkdirLocalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MkdirLocal not implemented")
}
func (UnimplementedFeServiceServer) CopyLocal(context.Context, *CopyLocalRequest) (*CopyLocalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyLocal not implemented")
}
func (UnimplementedFeServiceServer) MoveLocal(context.Context, *MoveLocalRequest) (*MoveLocalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveLocal not implemented")
}
func (UnimplementedFeServiceServer) Download(context.Context, *DownloadRequest) (*DownloadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Download not implemented")
}
func (UnimplementedFeServiceServer) Upload(context.Context, *UploadRequest) (*UploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upload not implemented")
}
func (UnimplementedFeServiceServer) RemoteMove(context.Context, *RemoteMoveRequest) (*RemoteMoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoteMove not implemented")
}
func (UnimplementedFeServiceServer) RemoveLocal(context.Context, *RemoveLocalRequest) (*RemoveLocalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveLocal not implemented")
}
func (UnimplementedFeServiceServer) mustEmbedUnimplementedFeServiceServer() {}

// UnsafeFeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FeServiceServer will
// result in compilation errors.
type UnsafeFeServiceServer interface {
	mustEmbedUnimplementedFeServiceServer()
}

func RegisterFeServiceServer(s grpc.ServiceRegistrar, srv FeServiceServer) {
	s.RegisterService(&FeService_ServiceDesc, srv)
}

func _FeService_ListHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeServiceServer).ListHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FeService/ListHosts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeServiceServer).ListHosts(ctx, req.(*ListHostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeService_ListLocalDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLocalDirRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeServiceServer).ListLocalDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FeService/ListLocalDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeServiceServer).ListLocalDir(ctx, req.(*ListLocalDirRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeService_MkdirLocal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MkdirLocalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeServiceServer).MkdirLocal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FeService/MkdirLocal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeServiceServer).MkdirLocal(ctx, req.(*MkdirLocalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeService_CopyLocal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyLocalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeServiceServer).CopyLocal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FeService/CopyLocal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeServiceServer).CopyLocal(ctx, req.(*CopyLocalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeService_MoveLocal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveLocalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeServiceServer).MoveLocal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FeService/MoveLocal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeServiceServer).MoveLocal(ctx, req.(*MoveLocalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeService_Download_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeServiceServer).Download(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FeService/Download",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeServiceServer).Download(ctx, req.(*DownloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeService_Upload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeServiceServer).Upload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FeService/Upload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeServiceServer).Upload(ctx, req.(*UploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeService_RemoteMove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoteMoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeServiceServer).RemoteMove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FeService/RemoteMove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeServiceServer).RemoteMove(ctx, req.(*RemoteMoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeService_RemoveLocal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveLocalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeServiceServer).RemoveLocal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.FeService/RemoveLocal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeServiceServer).RemoveLocal(ctx, req.(*RemoveLocalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FeService_ServiceDesc is the grpc.ServiceDesc for FeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.FeService",
	HandlerType: (*FeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListHosts",
			Handler:    _FeService_ListHosts_Handler,
		},
		{
			MethodName: "ListLocalDir",
			Handler:    _FeService_ListLocalDir_Handler,
		},
		{
			MethodName: "MkdirLocal",
			Handler:    _FeService_MkdirLocal_Handler,
		},
		{
			MethodName: "CopyLocal",
			Handler:    _FeService_CopyLocal_Handler,
		},
		{
			MethodName: "MoveLocal",
			Handler:    _FeService_MoveLocal_Handler,
		},
		{
			MethodName: "Download",
			Handler:    _FeService_Download_Handler,
		},
		{
			MethodName: "Upload",
			Handler:    _FeService_Upload_Handler,
		},
		{
			MethodName: "RemoteMove",
			Handler:    _FeService_RemoteMove_Handler,
		},
		{
			MethodName: "RemoveLocal",
			Handler:    _FeService_RemoveLocal_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "otaru.proto",
}
